% images: images in a [row x col x channel x numImages] array
% square: Checkerboard square size in meter size
% camera_params: camera parameters  matlab object

function [image_points,valid_idx, cam_extrinsics,camera_poses, world_points, err] = ComputeCamExtrinsics(images, square_size, camera_params)

image_points = [];
valid_idx = [];
cam_extrinsics = [];
camera_poses = [];
world_points = [];
err = int32(0);
camera_params = cameraParameters(camera_params);
num_of_images = size(images,4);

% Detect checkerboards in images
valid_idx = false(num_of_images,1);
board_points = cell(num_of_images,1);
board_sizes = cell(num_of_images,1);
valid_counter = int32(0);
for i=1:num_of_images
	% perform checkerboards detection in each image
    current_image=images(:,:,:,i);
    [current_board_points, board_size_detected] = detectCheckerboardPoints(current_image, 'PartialDetections', false);
	
	% mark if checkerboards is detected or not
    if (isequal(board_size_detected, [0 0]))
        valid_idx(i)=false;
    else
        valid_idx(i)=true;
    end
    board_points{i} = current_board_points;
    board_sizes{i} = board_size_detected;
    
end

if ~all(valid_idx)
    %err = "Error during detection of checkerboard in images";
    err = int32(-1);
    return;
end

num_of_valid_images = sum(valid_idx(:) == true);
image_points = zeros([size(board_points{1}) num_of_valid_images]);
board_size = zeros(1,2);
for i=1:num_of_valid_images
    if valid_idx(i)
        if (isequal(board_size, [0 0]))
            board_size = board_sizes{i};
        elseif (~isequal(board_size, board_sizes{i}))
              %err = "Detect checker board with different size at " + int2str(i);
              err = int32(-1);
              return;
        end
        image_points(:,:,i) = board_points{i};
    end
end

% compute extrinsics

cam_extrinsics = zeros(4,4,num_of_valid_images);
camera_poses = zeros(4,4,num_of_valid_images);

for i = 1:num_of_valid_images
    % transformations from the grid/world coordinates to the camera-based coordinates
    [orientation_matrix, translation_vector] = extrinsics(image_points(:,:,i), world_points, camera_params); 
   
    cam_extrinsics(:,:,i) = [inv(orientation_matrix) translation_vector'; [0 0 0 1]];
	
	% inverted of cam_extrinsics
    camera_poses(:,:,i)= [orientation_matrix -orientation_matrix*translation_vector'; [0 0 0 1]]; 

end
end


